{
  "version": 3,
  "sources": ["../../src/components/MatchContext.tsx", "../../src/components/Types.d.ts", "../../src/components/MatchText.tsx"],
  "sourcesContent": ["import React, {\n  useReducer,\n  useCallback,\n  createContext,\n  useEffect,\n  useMemo,\n} from 'react';\n\nimport {\n  EventContextProps,\n  MatchObjectProps,\n  IState,\n  IActions,\n  IActionTypes,\n  SearchProviderProps,\n} from './Types.d';\n\nconst scrollToView = (id: string, fixHeaderHeight: number = 0) => {\n  const dom = document.getElementById(id);\n  if (dom) {\n    const topOfElement =\n      dom.getBoundingClientRect().bottom + window.pageYOffset - fixHeaderHeight;\n    window.scroll({\n      top: topOfElement,\n      behavior: 'smooth',\n    });\n  }\n};\n\nconst defaultStore: IState = {\n  searchValue: '',\n  totalCount: 0,\n\n  activeCount: 0, // actived count, less than or equal totalCount\n  activeId: '', // active text id\n  matchedList: [],\n};\n\nconst searchEventStore: EventContextProps = {\n  onSearchChange: () => {},\n  onPrev: () => {},\n  onNext: () => {},\n  onUpdateMatchList: () => {},\n};\n\nconst reducer = (state: IState, action: IActions): IState => {\n  if (action.type === IActionTypes.setSearchValue) {\n    return {\n      ...state,\n      searchValue: action.payload.searchValue,\n    };\n  }\n\n  if (action.type === IActionTypes.setActiveMatch) {\n    return {\n      ...state,\n      activeId: action.payload.activeId,\n      activeCount: action.payload.activeCount,\n    };\n  }\n  if (action.type === IActionTypes.setMatchList) {\n    return {\n      ...state,\n      matchedList: action.payload,\n    };\n  }\n  return state;\n};\n\nexport const SearchContext = createContext(defaultStore);\nexport const SearchEventContext = createContext(searchEventStore);\n\nexport const SearchProvider = (props: SearchProviderProps) => {\n  const [store, dispatch] = useReducer(reducer, defaultStore);\n\n  const activeCount = store.activeCount;\n  const totalCount = store.matchedList?.length;\n  const onSearchChange = useCallback((e) => {\n    const searchValue = e.target.value;\n    dispatch({ type: IActionTypes.setSearchValue, payload: { searchValue } });\n  }, []);\n\n  // Calculate previous match text\n  const onPrev = useCallback(\n    (fixedHeaderHeight) => {\n      if (activeCount > 0) {\n        let prevActiveCount =\n          activeCount - 1 < 1 ? store.matchedList.length : activeCount - 1;\n        let matchIndex = prevActiveCount - 1;\n        let prevActiveId = store.matchedList[matchIndex].id;\n        dispatch({\n          type: IActionTypes.setActiveMatch,\n          payload: { activeId: prevActiveId, activeCount: prevActiveCount },\n        });\n\n        // scroll To View\n        if (typeof fixedHeaderHeight !== 'number') {\n          fixedHeaderHeight = props.value?.fixedHeaderHeight;\n        }\n        if (typeof props.value?.onScroll === 'function') {\n          props.value?.onScroll(prevActiveId, fixedHeaderHeight);\n        } else {\n          scrollToView(prevActiveId, fixedHeaderHeight);\n        }\n      }\n    },\n    [activeCount, totalCount]\n  );\n\n  // Calculate next match text\n  const onNext = useCallback(\n    (fixedHeaderHeight) => {\n      if (activeCount > 0) {\n        // update active count\n        let nextActiveCount =\n          activeCount + 1 > store.matchedList.length ? 1 : activeCount + 1;\n        let matchIndex = nextActiveCount - 1;\n        let nextActiveId = store.matchedList[matchIndex].id;\n        dispatch({\n          type: IActionTypes.setActiveMatch,\n          payload: { activeId: nextActiveId, activeCount: nextActiveCount },\n        });\n\n        // scroll To View\n        if (typeof fixedHeaderHeight !== 'number') {\n          fixedHeaderHeight = props.value?.fixedHeaderHeight;\n        }\n        if (typeof props.value?.onScroll === 'function') {\n          props.value?.onScroll(nextActiveId, fixedHeaderHeight);\n        } else {\n          scrollToView(nextActiveId, fixedHeaderHeight);\n        }\n      }\n    },\n    [activeCount, totalCount]\n  );\n\n  const onUpdateMatchList = useMemo(\n    (cacheList: MatchObjectProps[] = []) =>\n      (matchList: MatchObjectProps[] = []) => {\n        // cache initialList\n        cacheList = cacheList.concat(matchList);\n        dispatch({ type: IActionTypes.setMatchList, payload: cacheList });\n      },\n    [store.searchValue]\n  );\n\n  useEffect(() => {\n    // After calculating all match components, calculate totalCount and activeCount\n    if (store.matchedList.length > 0) {\n      dispatch({\n        type: IActionTypes.setActiveMatch,\n        payload: {\n          activeId: store.matchedList[0].id,\n          activeCount: 1,\n        },\n      });\n    }\n  }, [store.matchedList]);\n\n  return (\n    <SearchContext.Provider\n      value={{\n        ...store,\n        totalCount,\n        ignorecase: props.value?.ignorecase,\n      }}\n    >\n      <SearchEventContext.Provider\n        value={{\n          onSearchChange,\n          onUpdateMatchList,\n          onPrev,\n          onNext,\n        }}\n      >\n        {props.children}\n      </SearchEventContext.Provider>\n    </SearchContext.Provider>\n  );\n};\n", "import React from 'react';\n\nexport enum IActionTypes {\n  setSearchValue = 'setSearchValue',\n  setActiveMatch = 'setActiveMatch',\n  setMatchList = 'setMatchList',\n}\n\nexport interface MatchObjectProps {\n  id: string;\n  idCount: number;\n}\n\nexport interface IState {\n  searchValue: string;\n  totalCount: number;\n  activeCount: number;\n  activeId: string;\n  matchedList: MatchObjectProps[];\n  ignorecase?: boolean;\n}\n\nexport interface EventContextProps {\n  onSearchChange: (\n    event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>\n  ) => void;\n  onNext: (data: any) => void;\n  onPrev: (data: any) => void;\n  onUpdateMatchList: (matchedList: MatchObjectProps[]) => void;\n}\n\nexport interface IAction1 {\n  type: IActionTypes.setSearchValue;\n  payload: {\n    searchValue: string;\n  };\n}\n\nexport interface IAction2 {\n  type: IActionTypes.setActiveMatch;\n  payload: {\n    activeId: string;\n    activeCount: number;\n  };\n}\n\nexport interface IAction3 {\n  type: IActionTypes.setMatchList;\n  payload: MatchObjectProps[];\n}\nexport type IActions = IAction1 | IAction2 | IAction3;\n\nexport interface MatchTextProps {\n  id: string;\n  text?: string;\n  children?: React.ReactChild;\n  ignorecase?: boolean;\n}\n\nexport interface SearchProviderProps {\n  children: React.ReactNode;\n  value?: {\n    fixedHeaderHeight?: number;\n    onScroll?: (id: string, fixedHeight?: number) => void;\n    ignorecase?: boolean;\n  };\n}\n", "import React, { useContext, useMemo, useLayoutEffect } from 'react';\n\nimport { SearchContext, SearchEventContext } from './MatchContext';\nimport { MatchTextProps } from './Types';\n\nconst MARK = '__$CTRL_F$__';\n\nfunction escapeStr(str: string) {\n  return `${str}`.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n}\n\nfunction getMatchId(prefixId: string, index: number) {\n  return `${prefixId}_${index}`;\n}\n\nfunction getMatchText(\n  keyword: string,\n  text: string,\n  ignorecase: boolean = true\n) {\n  let keywordStr = keyword;\n  let textStr = text;\n  if (typeof keyword === 'number') {\n    keywordStr = `${keyword}`;\n  }\n  if (typeof text === 'number') {\n    textStr = `${text}`;\n  }\n  if (\n    typeof keywordStr !== 'string' ||\n    !keywordStr.trim() ||\n    typeof textStr !== 'string' ||\n    !textStr.trim() ||\n    !textStr.toLowerCase().includes(keywordStr.toLowerCase()) // case insensitive\n  ) {\n    return text;\n  }\n  const regexp = new RegExp(escapeStr(keywordStr), ignorecase ? 'gi' : 'g');\n  const matches: string[] = []; // save matched string, we will use this to overwrite keywordStr in the result string\n  const textWithMark = textStr.replace(regexp, (match) => {\n    matches.push(match);\n    return MARK;\n  });\n  const slices = textWithMark.split(MARK);\n  const data = {\n    slices,\n    matches,\n  };\n  return data;\n}\n\nexport const MatchText = (data: MatchTextProps): React.ReactElement<string> => {\n  let textStr = data.text!;\n  const id = data.id;\n  if (typeof data.children === 'string') {\n    textStr = data.children;\n  }\n  if (!textStr) {\n    return <>{textStr}</>;\n  }\n\n  let { searchValue, activeId, ignorecase } = useContext(SearchContext);\n  const { onUpdateMatchList } = useContext(SearchEventContext);\n  ignorecase =\n    typeof data.ignorecase === 'boolean' ? data.ignorecase : ignorecase;\n\n  const matchData = useMemo(\n    () => getMatchText(searchValue, textStr, ignorecase),\n    [searchValue, textStr]\n  );\n\n  useLayoutEffect(() => {\n    if (typeof matchData === 'object') {\n      const matchIds = matchData.matches.map((_, index) => ({\n        id: getMatchId(id, index),\n        idCount: index,\n      }));\n      onUpdateMatchList(matchIds);\n    }\n  }, [matchData]);\n\n  if (typeof matchData === 'string') {\n    return <>{matchData}</>;\n  }\n  const slicesLen = matchData.slices.length - 1;\n  return (\n    <React.Fragment>\n      {matchData.slices.map((slice, index) => {\n        if (index === slicesLen) {\n          return slice;\n        }\n        const matchId = getMatchId(id, index);\n        const color = matchId === activeId ? '#ff9632' : '#ffff00';\n        const matchStr = matchData.matches[index];\n        return (\n          <React.Fragment key={index}>\n            {slice}\n            <span\n              id={matchId}\n              style={{\n                backgroundColor: color,\n                display: 'inline-block',\n                whiteSpace: 'pre-wrap',\n              }}\n            >\n              {matchStr}\n            </span>\n          </React.Fragment>\n        );\n      })}\n    </React.Fragment>\n  );\n};\n\nexport default MatchText;\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,qBAMO;;;ACJA,MAAK;AAAL,YAAK,eAAL;AACL,sCAAiB;AACjB,sCAAiB;AACjB,oCAAe;AAAA,KAHL;;;ADeZ,MAAM,eAAe,CAAC,IAAY,kBAA0B,MAAM;AAChE,UAAM,MAAM,SAAS,eAAe;AACpC,QAAI,KAAK;AACP,YAAM,eACJ,IAAI,wBAAwB,SAAS,OAAO,cAAc;AAC5D,aAAO,OAAO;AAAA,QACZ,KAAK;AAAA,QACL,UAAU;AAAA;AAAA;AAAA;AAKhB,MAAM,eAAuB;AAAA,IAC3B,aAAa;AAAA,IACb,YAAY;AAAA,IAEZ,aAAa;AAAA,IACb,UAAU;AAAA,IACV,aAAa;AAAA;AAGf,MAAM,mBAAsC;AAAA,IAC1C,gBAAgB,MAAM;AAAA;AAAA,IACtB,QAAQ,MAAM;AAAA;AAAA,IACd,QAAQ,MAAM;AAAA;AAAA,IACd,mBAAmB,MAAM;AAAA;AAAA;AAG3B,MAAM,UAAU,CAAC,OAAe,WAA6B;AAC3D,QAAI,OAAO,SAAS,aAAa,gBAAgB;AAC/C,aAAO,iCACF,QADE;AAAA,QAEL,aAAa,OAAO,QAAQ;AAAA;AAAA;AAIhC,QAAI,OAAO,SAAS,aAAa,gBAAgB;AAC/C,aAAO,iCACF,QADE;AAAA,QAEL,UAAU,OAAO,QAAQ;AAAA,QACzB,aAAa,OAAO,QAAQ;AAAA;AAAA;AAGhC,QAAI,OAAO,SAAS,aAAa,cAAc;AAC7C,aAAO,iCACF,QADE;AAAA,QAEL,aAAa,OAAO;AAAA;AAAA;AAGxB,WAAO;AAAA;AAGF,MAAM,gBAAgB,gCAAc;AACpC,MAAM,qBAAqB,gCAAc;AAEzC,MAAM,iBAAiB,CAAC,UAA+B;AAxE9D;AAyEE,UAAM,CAAC,OAAO,YAAY,6BAAW,SAAS;AAE9C,UAAM,cAAc,MAAM;AAC1B,UAAM,aAAa,YAAM,gBAAN,mBAAmB;AACtC,UAAM,iBAAiB,8BAAY,CAAC,MAAM;AACxC,YAAM,cAAc,EAAE,OAAO;AAC7B,eAAS,EAAE,MAAM,aAAa,gBAAgB,SAAS,EAAE;AAAA,OACxD;AAGH,UAAM,SAAS,8BACb,CAAC,sBAAsB;AApF3B;AAqFM,UAAI,cAAc,GAAG;AACnB,YAAI,kBACF,cAAc,IAAI,IAAI,MAAM,YAAY,SAAS,cAAc;AACjE,YAAI,aAAa,kBAAkB;AACnC,YAAI,eAAe,MAAM,YAAY,YAAY;AACjD,iBAAS;AAAA,UACP,MAAM,aAAa;AAAA,UACnB,SAAS,EAAE,UAAU,cAAc,aAAa;AAAA;AAIlD,YAAI,OAAO,sBAAsB,UAAU;AACzC,8BAAoB,aAAM,UAAN,oBAAa;AAAA;AAEnC,YAAI,OAAO,cAAM,UAAN,oBAAa,cAAa,YAAY;AAC/C,sBAAM,UAAN,mBAAa,SAAS,cAAc;AAAA,eAC/B;AACL,uBAAa,cAAc;AAAA;AAAA;AAAA,OAIjC,CAAC,aAAa;AAIhB,UAAM,SAAS,8BACb,CAAC,sBAAsB;AA/G3B;AAgHM,UAAI,cAAc,GAAG;AAEnB,YAAI,kBACF,cAAc,IAAI,MAAM,YAAY,SAAS,IAAI,cAAc;AACjE,YAAI,aAAa,kBAAkB;AACnC,YAAI,eAAe,MAAM,YAAY,YAAY;AACjD,iBAAS;AAAA,UACP,MAAM,aAAa;AAAA,UACnB,SAAS,EAAE,UAAU,cAAc,aAAa;AAAA;AAIlD,YAAI,OAAO,sBAAsB,UAAU;AACzC,8BAAoB,aAAM,UAAN,oBAAa;AAAA;AAEnC,YAAI,OAAO,cAAM,UAAN,oBAAa,cAAa,YAAY;AAC/C,sBAAM,UAAN,mBAAa,SAAS,cAAc;AAAA,eAC/B;AACL,uBAAa,cAAc;AAAA;AAAA;AAAA,OAIjC,CAAC,aAAa;AAGhB,UAAM,oBAAoB,0BACxB,CAAC,YAAgC,OAC/B,CAAC,YAAgC,OAAO;AAEtC,kBAAY,UAAU,OAAO;AAC7B,eAAS,EAAE,MAAM,aAAa,cAAc,SAAS;AAAA,OAEzD,CAAC,MAAM;AAGT,gCAAU,MAAM;AAEd,UAAI,MAAM,YAAY,SAAS,GAAG;AAChC,iBAAS;AAAA,UACP,MAAM,aAAa;AAAA,UACnB,SAAS;AAAA,YACP,UAAU,MAAM,YAAY,GAAG;AAAA,YAC/B,aAAa;AAAA;AAAA;AAAA;AAAA,OAIlB,CAAC,MAAM;AAEV,WACE,mDAAC,cAAc,UAAf;AAAA,MACE,OAAO,iCACF,QADE;AAAA,QAEL;AAAA,QACA,YAAY,YAAM,UAAN,mBAAa;AAAA;AAAA,OAG3B,mDAAC,mBAAmB,UAApB;AAAA,MACE,OAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA,OAGD,MAAM;AAAA;;;AEhLf,sBAA4D;AAK5D,MAAM,OAAO;AAEb,qBAAmB,KAAa;AAC9B,WAAO,GAAG,MAAM,QAAQ,0BAA0B;AAAA;AAGpD,sBAAoB,UAAkB,OAAe;AACnD,WAAO,GAAG,YAAY;AAAA;AAGxB,wBACE,SACA,MACA,aAAsB,MACtB;AACA,QAAI,aAAa;AACjB,QAAI,UAAU;AACd,QAAI,OAAO,YAAY,UAAU;AAC/B,mBAAa,GAAG;AAAA;AAElB,QAAI,OAAO,SAAS,UAAU;AAC5B,gBAAU,GAAG;AAAA;AAEf,QACE,OAAO,eAAe,YACtB,CAAC,WAAW,UACZ,OAAO,YAAY,YACnB,CAAC,QAAQ,UACT,CAAC,QAAQ,cAAc,SAAS,WAAW,gBAC3C;AACA,aAAO;AAAA;AAET,UAAM,SAAS,IAAI,OAAO,UAAU,aAAa,aAAa,OAAO;AACrE,UAAM,UAAoB;AAC1B,UAAM,eAAe,QAAQ,QAAQ,QAAQ,CAAC,UAAU;AACtD,cAAQ,KAAK;AACb,aAAO;AAAA;AAET,UAAM,SAAS,aAAa,MAAM;AAClC,UAAM,OAAO;AAAA,MACX;AAAA,MACA;AAAA;AAEF,WAAO;AAAA;AAGF,MAAM,YAAY,CAAC,SAAqD;AAC7E,QAAI,UAAU,KAAK;AACnB,UAAM,KAAK,KAAK;AAChB,QAAI,OAAO,KAAK,aAAa,UAAU;AACrC,gBAAU,KAAK;AAAA;AAEjB,QAAI,CAAC,SAAS;AACZ,aAAO,0FAAG;AAAA;AAGZ,QAAI,EAAE,aAAa,UAAU,eAAe,8BAAW;AACvD,UAAM,EAAE,sBAAsB,8BAAW;AACzC,iBACE,OAAO,KAAK,eAAe,YAAY,KAAK,aAAa;AAE3D,UAAM,YAAY,2BAChB,MAAM,aAAa,aAAa,SAAS,aACzC,CAAC,aAAa;AAGhB,uCAAgB,MAAM;AACpB,UAAI,OAAO,cAAc,UAAU;AACjC,cAAM,WAAW,UAAU,QAAQ,IAAI,CAAC,GAAG,UAAW;AAAA,UACpD,IAAI,WAAW,IAAI;AAAA,UACnB,SAAS;AAAA;AAEX,0BAAkB;AAAA;AAAA,OAEnB,CAAC;AAEJ,QAAI,OAAO,cAAc,UAAU;AACjC,aAAO,0FAAG;AAAA;AAEZ,UAAM,YAAY,UAAU,OAAO,SAAS;AAC5C,WACE,oDAAC,sBAAM,UAAP,MACG,UAAU,OAAO,IAAI,CAAC,OAAO,UAAU;AACtC,UAAI,UAAU,WAAW;AACvB,eAAO;AAAA;AAET,YAAM,UAAU,WAAW,IAAI;AAC/B,YAAM,QAAQ,YAAY,WAAW,YAAY;AACjD,YAAM,WAAW,UAAU,QAAQ;AACnC,aACE,oDAAC,sBAAM,UAAP;AAAA,QAAgB,KAAK;AAAA,SAClB,OACD,oDAAC,QAAD;AAAA,QACE,IAAI;AAAA,QACJ,OAAO;AAAA,UACL,iBAAiB;AAAA,UACjB,SAAS;AAAA,UACT,YAAY;AAAA;AAAA,SAGb;AAAA;AAAA;",
  "names": []
}
