{
  "version": 3,
  "sources": ["../../src/components/MatchContext.tsx", "../../src/components/Types.d.ts", "../../src/components/MatchText.tsx"],
  "sourcesContent": ["import React, {\n  useReducer,\n  useCallback,\n  createContext,\n  useEffect,\n  useMemo,\n} from 'react';\n\nimport {\n  EventContextProps,\n  MatchObjectProps,\n  IState,\n  IActions,\n  IActionTypes,\n  SearchProviderProps,\n} from './Types.d';\n\nconst scrollToView = (id: string, fixHeaderHeight: number = 0) => {\n  const dom = document.getElementById(id);\n  if (dom) {\n    const topOfElement =\n      dom.getBoundingClientRect().bottom + window.pageYOffset - fixHeaderHeight;\n    window.scroll({\n      top: topOfElement,\n      behavior: 'smooth',\n    });\n  }\n};\n\nconst defaultStore: IState = {\n  searchValue: '',\n  totalCount: 0,\n\n  activeCount: 0, // actived count, less than or equal totalCount\n  activeId: '', // active text id\n  matchedList: [],\n};\n\nconst searchEventStore: EventContextProps = {\n  onSearchChange: () => {},\n  onPrev: () => {},\n  onNext: () => {},\n  onUpdateMatchList: () => {},\n};\n\nconst reducer = (state: IState, action: IActions): IState => {\n  if (action.type === IActionTypes.setSearchValue) {\n    return {\n      ...state,\n      searchValue: action.payload.searchValue,\n    };\n  }\n\n  if (action.type === IActionTypes.setActiveMatch) {\n    return {\n      ...state,\n      activeId: action.payload.activeId,\n      activeCount: action.payload.activeCount,\n    };\n  }\n  if (action.type === IActionTypes.setMatchList) {\n    return {\n      ...state,\n      matchedList: action.payload,\n    };\n  }\n  return state;\n};\n\nexport const SearchContext = createContext(defaultStore);\nexport const SearchEventContext = createContext(searchEventStore);\n\nexport const SearchProvider = (props: SearchProviderProps) => {\n  const [store, dispatch] = useReducer(reducer, defaultStore);\n\n  const activeCount = store.activeCount;\n  const totalCount = store.matchedList?.length;\n  const onSearchChange = useCallback((e) => {\n    const searchValue = e.target.value;\n    dispatch({ type: IActionTypes.setSearchValue, payload: { searchValue } });\n  }, []);\n\n  // Calculate previous match text\n  const onPrev = useCallback(\n    (fixedHeaderHeight) => {\n      if (activeCount > 0) {\n        let prevActiveCount =\n          activeCount - 1 < 1 ? store.matchedList.length : activeCount - 1;\n        let matchIndex = prevActiveCount - 1;\n        let prevActiveId = store.matchedList[matchIndex].id;\n        dispatch({\n          type: IActionTypes.setActiveMatch,\n          payload: { activeId: prevActiveId, activeCount: prevActiveCount },\n        });\n\n        // scroll To View\n        if (typeof fixedHeaderHeight !== 'number') {\n          fixedHeaderHeight = props.value?.fixedHeaderHeight;\n        }\n        if (typeof props.value?.onScroll === 'function') {\n          props.value?.onScroll(prevActiveId, fixedHeaderHeight);\n        } else {\n          scrollToView(prevActiveId, fixedHeaderHeight);\n        }\n      }\n    },\n    [activeCount, totalCount]\n  );\n\n  // Calculate next match text\n  const onNext = useCallback(\n    (fixedHeaderHeight) => {\n      if (activeCount > 0) {\n        // update active count\n        let nextActiveCount =\n          activeCount + 1 > store.matchedList.length ? 1 : activeCount + 1;\n        let matchIndex = nextActiveCount - 1;\n        let nextActiveId = store.matchedList[matchIndex].id;\n        dispatch({\n          type: IActionTypes.setActiveMatch,\n          payload: { activeId: nextActiveId, activeCount: nextActiveCount },\n        });\n\n        // scroll To View\n        if (typeof fixedHeaderHeight !== 'number') {\n          fixedHeaderHeight = props.value?.fixedHeaderHeight;\n        }\n        if (typeof props.value?.onScroll === 'function') {\n          props.value?.onScroll(nextActiveId, fixedHeaderHeight);\n        } else {\n          scrollToView(nextActiveId, fixedHeaderHeight);\n        }\n      }\n    },\n    [activeCount, totalCount]\n  );\n\n  const onUpdateMatchList = useMemo(\n    (cacheList: MatchObjectProps[] = []) =>\n      (matchList: MatchObjectProps[] = []) => {\n        // cache initialList\n        cacheList = cacheList.concat(matchList);\n        dispatch({ type: IActionTypes.setMatchList, payload: cacheList });\n      },\n    [store.searchValue]\n  );\n\n  useEffect(() => {\n    // After calculating all match components, calculate totalCount and activeCount\n    if (store.matchedList.length > 0) {\n      dispatch({\n        type: IActionTypes.setActiveMatch,\n        payload: {\n          activeId: store.matchedList[0].id,\n          activeCount: 1,\n        },\n      });\n    }\n  }, [store.matchedList]);\n\n  return (\n    <SearchContext.Provider\n      value={{\n        ...store,\n        totalCount,\n        ignorecase: props.value?.ignorecase,\n      }}\n    >\n      <SearchEventContext.Provider\n        value={{\n          onSearchChange,\n          onUpdateMatchList,\n          onPrev,\n          onNext,\n        }}\n      >\n        {props.children}\n      </SearchEventContext.Provider>\n    </SearchContext.Provider>\n  );\n};\n", "import React from 'react';\n\nexport enum IActionTypes {\n  setSearchValue = 'setSearchValue',\n  setActiveMatch = 'setActiveMatch',\n  setMatchList = 'setMatchList',\n}\n\nexport interface MatchObjectProps {\n  id: string;\n  idCount: number;\n}\n\nexport interface IState {\n  searchValue: string;\n  totalCount: number;\n  activeCount: number;\n  activeId: string;\n  matchedList: MatchObjectProps[];\n  ignorecase?: boolean;\n}\n\nexport interface EventContextProps {\n  onSearchChange: (\n    event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>\n  ) => void;\n  onNext: (data: any) => void;\n  onPrev: (data: any) => void;\n  onUpdateMatchList: (matchedList: MatchObjectProps[]) => void;\n}\n\nexport interface IAction1 {\n  type: IActionTypes.setSearchValue;\n  payload: {\n    searchValue: string;\n  };\n}\n\nexport interface IAction2 {\n  type: IActionTypes.setActiveMatch;\n  payload: {\n    activeId: string;\n    activeCount: number;\n  };\n}\n\nexport interface IAction3 {\n  type: IActionTypes.setMatchList;\n  payload: MatchObjectProps[];\n}\nexport type IActions = IAction1 | IAction2 | IAction3;\n\nexport interface MatchTextProps {\n  id: string;\n  text?: string;\n  children?: React.ReactChild;\n  ignorecase?: boolean;\n}\n\nexport interface SearchProviderProps {\n  children: React.ReactNode;\n  value?: {\n    fixedHeaderHeight?: number;\n    onScroll?: (id: string, fixedHeight?: number) => void;\n    ignorecase?: boolean;\n  };\n}\n", "import React, { useContext, useMemo, useLayoutEffect } from 'react';\n\nimport { SearchContext, SearchEventContext } from './MatchContext';\nimport { MatchTextProps } from './Types';\n\nconst MARK = '__$CTRL_F$__';\n\nfunction escapeStr(str: string) {\n  return `${str}`.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n}\n\nfunction getMatchId(prefixId: string, index: number) {\n  return `${prefixId}_${index}`;\n}\n\nfunction getMatchText(\n  keyword: string,\n  text: string,\n  ignorecase: boolean = true\n) {\n  let keywordStr = keyword;\n  let textStr = text;\n  if (typeof keyword === 'number') {\n    keywordStr = `${keyword}`;\n  }\n  if (typeof text === 'number') {\n    textStr = `${text}`;\n  }\n  if (\n    typeof keywordStr !== 'string' ||\n    !keywordStr.trim() ||\n    typeof textStr !== 'string' ||\n    !textStr.trim() ||\n    !textStr.toLowerCase().includes(keywordStr.toLowerCase()) // case insensitive\n  ) {\n    return text;\n  }\n  const regexp = new RegExp(escapeStr(keywordStr), ignorecase ? 'gi' : 'g');\n  const matches: string[] = []; // save matched string, we will use this to overwrite keywordStr in the result string\n  const textWithMark = textStr.replace(regexp, (match) => {\n    matches.push(match);\n    return MARK;\n  });\n  const slices = textWithMark.split(MARK);\n  const data = {\n    slices,\n    matches,\n  };\n  return data;\n}\n\nexport const MatchText = (data: MatchTextProps): React.ReactElement<string> => {\n  let textStr = data.text!;\n  const id = data.id;\n  if (typeof data.children === 'string') {\n    textStr = data.children;\n  }\n  if (!textStr) {\n    return <>{textStr}</>;\n  }\n\n  let { searchValue, activeId, ignorecase } = useContext(SearchContext);\n  const { onUpdateMatchList } = useContext(SearchEventContext);\n  ignorecase =\n    typeof data.ignorecase === 'boolean' ? data.ignorecase : ignorecase;\n\n  const matchData = useMemo(\n    () => getMatchText(searchValue, textStr, ignorecase),\n    [searchValue, textStr]\n  );\n\n  useLayoutEffect(() => {\n    if (typeof matchData === 'object') {\n      const matchIds = matchData.matches.map((_, index) => ({\n        id: getMatchId(id, index),\n        idCount: index,\n      }));\n      onUpdateMatchList(matchIds);\n    }\n  }, [matchData]);\n\n  if (typeof matchData === 'string') {\n    return <>{matchData}</>;\n  }\n  const slicesLen = matchData.slices.length - 1;\n  return (\n    <React.Fragment>\n      {matchData.slices.map((slice, index) => {\n        if (index === slicesLen) {\n          return slice;\n        }\n        const matchId = getMatchId(id, index);\n        const color = matchId === activeId ? '#ff9632' : '#ffff00';\n        const matchStr = matchData.matches[index];\n        return (\n          <React.Fragment key={index}>\n            {slice}\n            <span\n              id={matchId}\n              style={{\n                backgroundColor: color,\n                display: 'inline-block',\n                whiteSpace: 'pre-wrap',\n              }}\n            >\n              {matchStr}\n            </span>\n          </React.Fragment>\n        );\n      })}\n    </React.Fragment>\n  );\n};\n\nexport default MatchText;\n"],
  "mappings": "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",
  "names": []
}
